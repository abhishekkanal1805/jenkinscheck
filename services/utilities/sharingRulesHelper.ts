/*!
 * Copyright Â© 2019 Deloitte. All rights reserved.
 */

import * as log from "lambda-log";
import * as moment from "moment";
import { Op } from "sequelize";
import { Constants } from "../../common/constants/constants";
import { tableNameToResourceTypeMapping } from "../../common/objects/tableNameToResourceTypeMapping";
import { ConnectionDataResource } from "../../models/CPH/connection/connectionDataResource";
import { SharingRule } from "../../models/CPH/connection/sharingRule";
import { QueryGenerator } from "./queryGenerator";

export class SharingRulesHelper {
  /**
   * This function takes queryObject (generated by calling function for queryParams) and
   * connection object and appends sharingRule sequelize query clause with queryObject if
   * applicable otherwise returns queryObject as whereClause or return empty object.
   *
   * @param queryObject
   * @param {ConnectionDataResource} connection
   * @param model
   * @param {string} accessLevel
   * @return {{}}
   */
  public static addSharingRuleClause(queryObject: any, connection: ConnectionDataResource, model: any, accessLevel: string) {
    log.info("Entering SharingRulesHelper :: addSharingRuleClause()");
    const serviceName = model.getTableName();
    const whereClause = {};
    if (connection && connection.sharingRules && connection.sharingRules.length > 0) {
      /*
       * If SharingRules are present in connection then sharingRuleConditionClause is generated and
       * appended to the queryObject with logical AND operation.
       */
      const sharingRuleConditionClause: any = SharingRulesHelper.getSharingRulesClause(
        connection.sharingRules,
        tableNameToResourceTypeMapping[serviceName],
        accessLevel
      );
      // If sharing rules present then add to where clause
      if (sharingRuleConditionClause[Op.or].length) {
        whereClause[Op.and] = [queryObject, sharingRuleConditionClause];
      }
    }
    log.info("Exiting SharingRulesHelper :: addSharingRuleClause()");
    return whereClause;
  }

  /**
   * This function takes sharingRule array and iterate over that array and calls getCriteriaClause
   * to generate the sequelize query clauses.
   * All sharingRules are by default connected with each other with logical OR operation.
   * AccessLevel defines which sharingRule is applicable for the called endpoint.
   *
   * @param {SharingRule[]} sharingRules
   * @param {string} serviceName
   * @param {string} accessLevel
   * @return {{}}
   */
  public static getSharingRulesClause(sharingRules: SharingRule[], serviceName: string, accessLevel: string) {
    log.info("Entering SharingRulesHelper :: getSharingRulesClause()");
    const sharingRuleClause = {};
    sharingRuleClause[Op.or] = [];
    const accessLevelMap = {
      [Constants.ACCESS_READ]: [Constants.ACCESS_READ],
      [Constants.ACCESS_EDIT]: [Constants.ACCESS_READ, Constants.ACCESS_EDIT]
    };
    for (const sharingRule of sharingRules) {
      if (
        sharingRule.resourceType.toLowerCase() === serviceName.toLowerCase() &&
        accessLevelMap[sharingRule.accessLevel.toLowerCase()].indexOf(accessLevel) > -1 &&
        sharingRule.criteria
      ) {
        const operator = sharingRule.operator ? sharingRule.operator : Constants.OPERATION_OR;
        // Below line of code gets all the query clause for all criteria inside SharingRule.
        log.info("Entering SharingRulesHelper :: getCriteriaClause()");
        const criteria = SharingRulesHelper.getCriteriaClause(sharingRule.criteria, operator);
        log.info("Exiting SharingRulesHelper :: getCriteriaClause()");
        sharingRuleClause[Op.or].push(criteria);
      }
    }
    log.info("Exiting SharingRulesHelper :: getSharingRulesClause()");
    return sharingRuleClause;
  }

  /**
   * This function takes criteria array converts it into a sequelize query clause.
   * It also calls itself recursively to generate query clause if there is any
   * nested criteria present.
   * Function implementation is mainly split into to blocks on takes care of single
   * criteria types and other takes care of group type.
   *
   * @param {any[]} criteria
   * @param {string} operator
   * @return {{}}
   */
  public static getCriteriaClause(criteria: any[], operator: string) {
    const operationMap = {
      greaterThan: [Op.gt, "gt"],
      greaterThanOrEqual: [Op.gte, "ge"],
      lessThan: [Op.lt, "lt"],
      lessThanOrEqual: [Op.lte, "le"],
      equal: [Op.eq, ""],
      notEqual: [Op.ne, "ne"]
    };
    const operatorMap = { OR: Op.or, AND: Op.and };
    /*
     * If operator is mentioned inside sharingRule object and sent to this function then that
     * operator is used as logical operator between all the primary criteria otherwise OR is considered
     */
    operator = operator ? operatorMap[operator] : operatorMap[Constants.OPERATION_OR];
    const conditionArray = {};
    conditionArray[operator] = [];
    for (const criterion of criteria) {
      if (criterion.type === Constants.TYPE_SINGLE) {
        conditionArray[operator].push(SharingRulesHelper.generateConditionForSingleCriteria(criterion, operationMap));
      } else {
        // All the criteria with type "group" are taken care in this block with recursive calls..
        const criteriaGroupConditions: any = SharingRulesHelper.getCriteriaClause(criterion.criteria, criterion.operator);
        conditionArray[operator].push(criteriaGroupConditions);
      }
    }
    return conditionArray;
  }

  /**
   * It will create addtional filter condtion for date based on date pattern
   * If input is 2019-03-12T07:32:18.279Z, then as per FHIR it should match for 2019, 2019-03, 2019-03-12
   * if dateObject is of type datetime then add condition for data, year-month, year
   * if dateObject is of type date then add condition for year-month, year
   * if dateObject is of type year-month then add condition for year
   * if dateObject is of type year then don't add any condition
   * @static
   * @param {*} column Column object which contains column Hireachy
   * @param {*} value Input date value
   * @param {*} dateCondition DateCondtion object which stores all search conditions
   * @param {string} currentDatePattern Date pattern of input dateObject
   * @memberof SharingRulesHelper
   */
  public static getAddtionalDateFilters(column: any, value: any, dateCondition: any, currentDatePattern: string) {
    const condition: any = {
      [Op.or]: []
    };
    const dateMomentObject = moment(value, currentDatePattern);
    switch (currentDatePattern) {
      case Constants.DATE_TIME:
        QueryGenerator.createParitalSearchConditions(column, [dateMomentObject.format(Constants.DATE)], condition, Constants.PREFIX_EQUAL, true);
      case Constants.DATE:
        QueryGenerator.createParitalSearchConditions(column, [dateMomentObject.format(Constants.YEAR_MONTH)], condition, Constants.PREFIX_EQUAL, true);
      case Constants.YEAR_MONTH:
        QueryGenerator.createParitalSearchConditions(column, [dateMomentObject.format(Constants.YEAR)], condition, Constants.PREFIX_EQUAL, true);
      default:
        dateCondition[Op.or] = dateCondition[Op.or].concat(condition[Op.or]);
        break;
    }
  }

  /**
   * This function takes date as input created sequelize query clause for nested array.
   * @param {*} column Column object which contains column Hireachy
   * @param {string} dateOperator it specifies operation type on date
   * @param {string} value Input date value
   * @param {*} dateCondition DateCondtion object which stores all search conditions
   * @memberof SharingRulesHelper
   */
  public static generateConditionForNestedDate(column: any, dateOperator: string, value: string, dateCondition: any) {
    const condition: any = {
      [Op.or]: []
    };
    if (!dateCondition[Op.or]) {
      dateCondition[Op.or] = [];
    }
    const dateMomentObject = moment(value, Constants.DATE);
    const nextDate = moment(dateMomentObject.add({ [Constants.PERIOD_DAYS]: 1 })).format(Constants.DATE);
    let datePattern = Constants.DATE_TIME;
    if (moment(value, Constants.DATE_TIME, true).isValid()) {
      if (!dateOperator) {
        // if dateOperator is empty then assume it as equal operation
        dateOperator = Constants.PREFIX_EQUAL;
      }
      QueryGenerator.createParitalSearchConditions(column, [value], condition, dateOperator, true);
      dateCondition[Op.or] = dateCondition[Op.or].concat(condition[Op.or]);
    } else {
      datePattern = Constants.DATE;
      // If pattern is DATE
      if ([Constants.PREFIX_GREATER_THAN, Constants.PREFIX_LESS_THAN_EQUAL].indexOf(dateOperator) > -1) {
        value = nextDate;
        // As date is a string we have to consider current date also in query
        const operatorMapping = {
          [Constants.PREFIX_GREATER_THAN]: Constants.PREFIX_GREATER_THAN_EQUAL,
          [Constants.PREFIX_LESS_THAN_EQUAL]: Constants.PREFIX_LESS_THAN
        };
        dateOperator = operatorMapping[dateOperator] ? operatorMapping[dateOperator] : dateOperator;
      }
      if (dateOperator === Constants.PREFIX_NOT_EQUAL) {
        // for Not equal
        QueryGenerator.createParitalSearchConditions(column, [value], condition, Constants.PREFIX_LESS_THAN, true);
        QueryGenerator.createParitalSearchConditions(column, [nextDate], condition, Constants.PREFIX_GREATER_THAN_EQUAL, true);
        dateCondition[Op.or].push({
          [Op.and]: condition[Op.or]
        });
      } else if (dateOperator) {
        QueryGenerator.createParitalSearchConditions(column, [value], condition, dateOperator, true);
        dateCondition[Op.or] = dateCondition[Op.or].concat(condition[Op.or]);
      } else {
        // for equal
        QueryGenerator.createParitalSearchConditions(column, [value], condition, Constants.PREFIX_GREATER_THAN_EQUAL, true);
        QueryGenerator.createParitalSearchConditions(column, [nextDate], condition, Constants.PREFIX_LESS_THAN, true);
        dateCondition[Op.or].push({
          [Op.and]: condition[Op.or]
        });
      }
    }
    if (dateOperator != Constants.PREFIX_NOT_EQUAL) {
      // for not equal operation we will not additional filter
      SharingRulesHelper.getAddtionalDateFilters(column, value, dateCondition, datePattern);
    } else {
      condition[Op.or] = [];
      // For Not Equal operation we will return records where attribute doesn't exists or != to request value
      QueryGenerator.createDateNotEqualSearchConditions(column, [value, nextDate], condition);
      dateCondition[Op.or].push({
        [Op.or]: condition[Op.or]
      });
    }
  }

  /**
   * Generates criteria condition for criteria of single type.
   * @param criterion
   * @param operationMap
   * @return {{}}
   */
  public static generateConditionForSingleCriteria(criterion: any, operationMap) {
    // All the criteria with type "single" are taken care in this block.
    let value = criterion.hasOwnProperty("value") ? criterion.value : SharingRulesHelper.expressionEvaluator(criterion.valueExpression.expression);
    let operation = operationMap[criterion.operation][0];
    let parentAttribute = [Constants.DEFAULT_SEARCH_ATTRIBUTES, criterion.element].join(Constants.DOT_VALUE);
    const arrFlag = parentAttribute.indexOf(Constants.ARRAY_SEARCH_SYMBOL) > -1;
    if (typeof value == Constants.TYPE_STRING && (moment(value, Constants.DATE_TIME, true).isValid() || moment(value, Constants.DATE, true).isValid())) {
      // validate for date & datetime pattern
      // This block takes care of generating Date type conditions where year, year-month etc formats considered.
      const dateOperation = operationMap[criterion.operation][1];
      const dateCondition: any = {
        [Op.or]: []
      };
      const column = { columnHierarchy: parentAttribute };
      if (arrFlag) {
        // If date present in array of objects
        SharingRulesHelper.generateConditionForNestedDate(column, dateOperation, value, dateCondition);
      } else {
        QueryGenerator.createDateSearchConditions(column, [dateOperation + value], dateCondition);
      }
      return dateCondition;
    } else {
      const attributes = criterion.element.split(Constants.DOT_VALUE);
      operation = arrFlag ? Op.contains : operation;
      const condition: any = {
        [Op.or]: []
      };
      let compareOperator = operationMap[criterion.operation][1];
      if (!compareOperator) {
        // if dateOperator is empty then assume it as equal operation
        compareOperator = Constants.PREFIX_EQUAL;
      }
      if (arrFlag) {
        parentAttribute = Constants.DEFAULT_SEARCH_ATTRIBUTES;
        const nestedAttributes = {};
        // as we are adding dataResource so getNestedAttributes will take care of array of object pattern
        if (compareOperator != Constants.PREFIX_EQUAL) {
          const notEqualParentAttribute = [Constants.DEFAULT_SEARCH_ATTRIBUTES, criterion.element].join(Constants.DOT_VALUE);
          const column = { columnHierarchy: notEqualParentAttribute };
          QueryGenerator.createParitalSearchConditions(column, [value], condition, compareOperator, false);
          return condition;
        }
        QueryGenerator.getNestedAttributes(attributes, value, nestedAttributes, false);
        value = nestedAttributes;
        return {
          [parentAttribute]: {
            [operation]: value
          }
        };
      } else {
        condition[Op.or].push({
          [parentAttribute]: {
            [operation]: value
          }
        });
        if (compareOperator == Constants.PREFIX_NOT_EQUAL) {
          // For Not Equal operation we will return records where attribute doesn't exists or != to request value
          const notEqualParentAttribute = [Constants.DEFAULT_SEARCH_ATTRIBUTES, criterion.element].join(Constants.DOT_VALUE);
          const column = { columnHierarchy: notEqualParentAttribute };
          QueryGenerator.createParitalSearchConditions(column, [value], condition, Constants.PREFIX_NOT_EQUAL, false);
        }
        return condition;
      }
    }
  }

  /**
   * This function takes a predefined date expression comes from Sharing Rule valueExpression
   * and convert it into a valid date string.
   *
   * @param {string} expression : expression to be eveluated
   * @returns {string}
   */
  public static expressionEvaluator(expression: string) {
    const days: any = Constants.DAYS_IN_WEEK;
    const months: any = Constants.MONTHS_IN_YEAR;
    const parenthesesStart: number = expression.indexOf(Constants.OPENING_PARENTHESES);
    const parenthesesEnd: number = expression.indexOf(Constants.CLOSING_PARENTHESES);
    const value: string = expression.substr(parenthesesStart + 1, parenthesesEnd - parenthesesStart - 1);
    let evaluatedValue: string;
    if (days[value] > -1) {
      const daydiff = moment().day() <= days[value] ? days[value] - 7 : days[value];
      evaluatedValue = moment()
        .day(daydiff)
        .format(Constants.DATE);
      log.debug("evaluatedValue: ", [moment().day(), days[value], evaluatedValue]);
    } else if (months[value] > -1) {
      const month = months[value];
      const lastDate: number = moment()
        .month(month)
        .daysInMonth();
      evaluatedValue = moment().year() + Constants.HYPHEN + (month < 9 ? "0" + (month + 1) : Constants.EMPTY_VALUE + (month + 1)) + Constants.HYPHEN + lastDate;
    } else {
      evaluatedValue = value + Constants.HYPHEN + "12" + Constants.HYPHEN + "31";
    }
    return evaluatedValue;
  }
}
